### 计算机网络

##### OSI七层参考模型

应用层 表示层 会话层 传输层 网络层 数据链路层 物理层

各层各司其职，下层为上层提供服务

##### 奈氏准则

理想条件下，为避免码间串扰，码元的传输速率上限受限。信道的频带越宽，则能允许传输更多的码元，传输速率也更快。

##### 数据链路层

数据链路层传送的是数据帧，由IP数据包封装而来。

三大任务：

​	**封装成帧**

​	**透明传输**

​	**差错检验**

##### 网络层

路由器是网络层设备，主要是来转发数据包。

​	arp协议

​	发送广播包来获取指定IP主机的mac地址。

​	arp欺骗

​	由于发送的是广播包，黑客软件完全可以获取到并返回错误的mac地址。（网络执法官）

​	ICMP协议（网络控制报文协议）

​	ping(packet internet group) 因特网包探测器 用来检测网通不通

​	IGMP 和多播相关

##### 传输层

​	TCP UDP 使用场景区分

​	TCP：需要将传输的文件分段，传输建立会话，可靠传输，流量控制，拥塞避免

​	UDP：一个数据包就能完成数据通信，不分段，不建立连接，不可靠传输。（DNS域名解析，QQ聊天，多播，直播）



​	UDP首部开销小，只有8个字节。TCP首部20字节。

​	TCP的三大特性：

 * 可靠传输

   通过滑动窗口和确认重传机制

 * 流量控制

   通过滑动窗口实现。在三次握手的时候协商好各自能接收的最大缓存，双方根据这个缓存设置发送窗口。当某一方处理数据不及时，便可以通过改变窗口大小，来通知对方降低发送速率。

 * 拥塞避免

   慢开始：

   发送方维持一个拥塞窗口

   当TCP连接初始化时，将拥塞窗口置为1（报文段），慢开始的门限设置为16，慢开始的窗口大小随指数规律增长，到达门限值后，随加法增大。一旦出现网络拥塞，窗口大小再次设为初始值1，而门限值设置为出现拥塞时窗口大小的一般。

   快重传 

   在发现某个数据包丢了后，连续发送三个确认，让对方重传该数据包。而发送方在连续收到三个确认的情况下，采用快恢复机制。

   快恢复

   发送方一旦收到三个确认，就将拥塞窗口大小设为当前窗口的一半，然后加法增大。

   

   #### TCP三次握手 四次挥手

   1. 为什么三次握手，三次握手的大致流程

      握手是为了协商双方的参数，比如接收窗口大小。而三次握手是为了让双方都知道对方有发送数据，接收数据的能力，如果仅仅是两次握手，那么被动方在发送握手消息后，没有得到回应，就无法确定自己刚刚发送的消息有没有被对方接收。

      大致流程：

      客户端首先发送带syn标记，序号为 X的数据段到服务端

      服务端收到syn请求后，发送一个带syn和ack标记的，确认号为X+1,序号Y的数据段到客户端。

      客户端接收到服务端的SYN信号，也是应答信号后，返回带ack标记的，确认号为Y+1的数据段给服务端。

      至此，三次握手完成。

   2. 为什么采用四次挥手，大致流程

      因为TCP连接的双方采用全双工通信，一方停止想停止发送数据，就主动挥手，对方应答。但对方很有可能还有数据要继续发送，因此等另一方发送完后，其发送挥手信号，再应答，这样下来总的流程需要四次挥手。

      大致流程：

      一开始，假设客户端A数据发送完毕，A发送带fin标记的数据段给服务端B，此时A进入FIN_WAIT1状态。B接收到A的消息后，返回一个ack数据段，B进入CLOSE_WAIT状态。A收到B的确认后，进入FIN_WAIT2状态。待B也发送完数据后，B发送带fin标记的数据段给A，B进入LAST_ACK状态。A收到B的中断连接的信号，回复一个ack信号，并进入TIME_WAIT状态，B收到回应后，连接断开。

      TIME_WAIT为什么要维持2MSL时间？

      因为很有可能A发送的确认，由于网络问题，B没收到，那么B就得重发fin信号，A得确保能收到重发的fin信号。这样一个往返的时间就是2MSL。

      
      
      服务端出现大量CLOSE_WAIT状态的原因：
      
      某种情况下对方关闭了socket链接，但是我方忙与读或者写，没有关闭连接。

#### TCP粘包拆包

- TCP是**基于字节流的**，虽然应用层和TCP传输层之间的数据交互是大小不等的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，**没有边界**；
- 从TCP的帧结构也可以看出，在TCP的首部**没有表示数据长度的字段**

基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能。

**接收端收到的一个数据包中包含了发送端发送的两个数据包的信息**，这种现象即为粘包

![](C:\Users\kyrie\Pictures\TCP粘包.PNG)

接收端收到了两个数据包，但是这两个数据包**要么是不完整的，要么就是多出来一块**，这种情况即发生了拆包和粘包

![](C:\Users\kyrie\Pictures\TCP拆包.PNG)

#### Http

##### get&post

`Get` 方法的含义是请求**从服务器获取资源**，这个资源可以是静态的文本、页面、图片视频等。

而`POST` 方法则是相反操作，它向 `URI` 指定的资源提交数据，数据就放在报文的 body 里。

**幂等**和**安全**

- 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。
- 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。

很明显 **GET 方法就是安全且幂等的**，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。

**POST** 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多个资源，所以**不是幂等**的。

##### http1.0&http1.1

1. 长连接

早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。

为了解决上述 TCP 连接问题，HTTP/1.1 提出了**长连接**的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额
外开销，减轻了服务器端的负载

2. 管道传输

HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。

即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间。**

##### HTTP&HTTPS

1. HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。

2. HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。

3. HTTP 的端口号是 80，HTTPS 的端口号是 443。

4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。



HTTPS 采用的是**对称加密**和**非对称加密**结合的「混合加密」方式：

- 在通信建立前采用**非对称加密**的方式交换「会话秘钥」，后续就不再使用非对称加密。
- 在通信过程中全部使用**对称加密**的「会话秘钥」的方式加密明文数据。

采用「混合加密」的方式的原因：

- **对称加密**只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
- **非对称加密**使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。


