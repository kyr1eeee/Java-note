## redis

STRLEN key1 输出的是key1对应字符串的字节数，而不是字符数

#### 二进制安全

Redis的字符串存储不像C语言那样以'\0'表示字符串的结束

```java
struct sdshdr {//redis 的字符串采用字符数组的方式存储

int len;//记录buf数组大小

int free;//记录buf数组还有多少可用空间

char buf[];//字符串实体，保存字符串的内容

};
```

#### 淘汰策略



#### redis是单线程还是多线程？

redis的在数据计算处理的时候肯定是单线程的，不过在redis6.0版本，加入了IO Threads，支持多线程参与IO操作，读取多客户端请求的数据。

#### 缓存穿透

解决办法：

* 把MySQL不存在的key也缓存在redis中，下一次请求可以直接查缓存。

占用缓存的空间。而且如果下一次请求的key改变了，但是同样缓存里面数据库里面都没有，还是会打到数据库。

* 布隆过滤器

布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素**很可能在**。这就是布隆过滤器的基本思想。

应用的时候：

查询请求进来的时候，先利用布隆过滤器看当前key在不在海量数据库里面，如果在（虽然可能存在误判，但是概率低），然后才去查缓存，缓存没有再查数据库。这样就能挡住大部分的非法攻击。

#### 缓存击穿

至于**缓存击穿**嘛，这个跟**缓存雪崩**有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了DB，而缓存击穿不同的是**缓存击穿**是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，

解决办法：

**缓存击穿**的话，设置热点数据永远不过期。或者加上互斥锁就能搞定了（缓存不存在的话，获取锁的前提下才能访问数据库）。

![](C:\Users\kyrie\Pictures\缓存击穿解决方法.PNG)