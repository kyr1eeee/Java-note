### 项目介绍的点（STAR）

1. 项目架构

   

2. 项目亮点&难点

3. 怎么解决难点&怎么实现亮点

4. 压测的结果，对比提升

#### 页面缓存

访问商品列表页面时，倘若是高并发情况，第一个用户访问，redis缓存中没有已经渲染好的页面，因此需要根据数据库的商品信息，html静态页面，手动渲染后，将完整的渲染好的页面存入redis(key:goodkey:ls    value:html字符串)，然后返回。那么之后的用户访问此页面，就不需要服务器进行视图解析，直接访问缓存就行。

#### produces(RequestMapping里面的属性)

produces不是注解，它是注解@requestMapping注解里面的属性项，

**它的作用是指定返回值类型**，不但可以设置返回值类型还可以设定返回值的字符编码

#### url缓存

url缓存与页面缓存差不多，只不过粒度要小。比如缓存某个商品的详情页，不同的商品对应不同的详情，所有粒度显而易见要小。

（注意：两者的缓存有效期不能设置太长，否则页面实时性也就体现不了。）



#### 对象缓存

在UserService里面的getUserById(){}方法中，先尝试从redis缓存中获取，如果获取到了，直接返回，获取不到，从数据库获取，并存到redis中。原理还是和上面差不多，只不过由于对象可能会频繁更新，比如updateUserPasswordById()方法就应该更新完数据库的user后，同时把缓存的user也更新，避免缓存一致性问题。（关于缓存更新的问题，参见https://blog.csdn.net/tTU1EvLDeLFq5btqiK/article/details/78693323）

#### get和post区别

幂等性（多次执行get得到的结果会是一致的），安全性（多次post会改变数据库状态）

#### 页面静态化（/static/xx.htm）

返回静态的页面，然后静态页面通过ajax请求动态的参数数据。从而减少服务器的访问压力

#### 项目中出现的问题

没有在applicationProperty中配置static相关属性，导致静态页面ajax

#### 超卖

超卖就是指，高并发下，秒杀系统不完备时，出现秒杀物品卖出数量超过库存的情况

##### 解决办法

由于miaosha serivce流程是

1. 判断库存是否足够，通过goods service
2. 判断是否秒杀过，通过miaosha service
3. 减库存（goods service），下订单，写秒杀订单(orderservice)，

有可能两个用户进程在库存为1的时候，进入了秒杀 service，都判断了库存是足够的，也都没有下过订单，

就会进入到减库存，下订单环节，出现超卖。

因此 可以通过在第三步事务中减库存时，通过sql语句update数据库排它锁的机制，实现只有一人能抢到最后一件商品，另外一个人的事务回滚，返回。

但是即便是这样，还是会出现另外一种问题。

如果一个用户短时间内发了两个请求，1  2 步判断都通过了，然后执行第三步的事务，抢到了两个商品。

解决这个问题可以通过，在miaosha_order表中，建立关于userId&goodsId的唯一索引，那么第二次插入订单到这个表的时候就会报错从而回滚。

当然，防护这种情况还可以通过在用户秒杀时提交验证码这种形式，延缓用户秒杀的时间。

#### 有一个超卖问题，更加严重！！！

发现数据库的商品数量为0，以为已经解决了超卖的问题，但是发现生成订单的订单表里面的订单数居然比商品数量大。反复的检查业务代码，观察逻辑哪里出了问题。

千辛万苦，终于找到了，原来是

![](C:\Users\kyrie\Pictures\秒杀逻辑漏洞.PNG)

应该是事务在减库存失败后，还是会执行return语句，也就会生成订单，因此出现了问题。

#### 装你妈的rabbitmq都这么多坑







#### HttpServletResponse编码问题

在做防刷限流的时候，自定义拦截器拦截包含自定义注解的controller的方法时，在实现拦截的逻辑的时候，将请求过于频繁的消息返回客户端时，输出流输出的response中，但是却未指定response的编码方式，导致在测试的时候老显示不出效果，试了debug服务端找错，又到前端代码找错，最后在浏览器提取返回的信息发现，是乱码了。这才意识到最先开始学httpservlet的时候，指定编码格式给忘了。

#### 秒杀的逻辑

GoodsList ->传递 goodId给 goodDetail.htm

->根据goodId,发送ajax请求得到相应的商品data（包括秒杀商品的价格，开始时间等）

 ->根据data渲染html页面 ，如果秒杀时间还没到，倒计时提醒用户 

->秒杀时间到

->ajax异步请求服务端，得到数学算式验证码，redis保存60秒的以该商品和该用户url和该用户ID为key的算式结果为value的键。

 ->渲染验证码图片 

->用户输入验证码，点击秒杀 

->ajax请求服务端请求秒杀地址，服务端先验证验证码是否匹配，然后生成随机字符串并加密保存在redis中，并返回客户端作为秒杀地址。

 ->客户端根据返回的地址，ajax请求服务端，进行秒杀

-> 服务端验证地址是否与redis的key(由useId和goodsId生成)匹配

->验证匹配后，根据内存状态判断库存够不够，够的话预减库存redis，再判断之前是否秒杀过，然后进入秒杀逻辑

->将请求（包含用户ID，goodsId）放入消息队列，排队，请求直接返回

->客户端轮询服务端，根据服务端返回的状态，可能秒杀失败，可能还在排队，也可能秒杀成功。